##  1、冒泡排序

**冒泡排序** （Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。

### +算法步骤

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。


![img](http://ddrv.cn/docs/SortingAlgorithm/res/bubbleSort.gif)

#### js代码实现

```js
function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i < len - 1; i++) {
        for (var j = 0; j < len - 1 - i; j++) {
            if (arr[j] > arr[j+1]) {      // 相邻元素两两对比
                var temp = arr[j+1];      // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
        console.log(arr)
    }
    return arr;
}
bubbleSort([20,14,31,22,2,9,66,10])//[2, 9, 10, 14, 20, 22, 31, 66]
```
```
相邻元素两两对比
第一轮[14, 20, 22, 2, 9, 31, 10, 66]
第二轮[14, 20, 2, 9, 22, 10, 31, 66]
第三轮[14, 2, 9, 20, 10, 22, 31, 66]
第四轮[2, 9, 14, 10, 20, 22, 31, 66]
第五轮[2, 9, 10, 14, 20, 22, 31, 66]
第六轮[2, 9, 10, 14, 20, 22, 31, 66]
第七轮[2, 9, 10, 14, 20, 22, 31, 66]
```



## 2、选择排序

**选择排序** 是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。

### 1. 算法步骤

1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置
2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。
3. 重复第二步，直到所有元素均排序完毕。

![选择排序](http://ddrv.cn/docs/SortingAlgorithm/res/selectionSort.gif)

#### js代码实现

```javascript
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            if (arr[j] < arr[minIndex]) {    // 寻找最小的数
                minIndex = j;                // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
selectionSort([30,24,65,12,2,63,44,22])//[2, 12, 22, 24, 30, 44, 63, 65]
```
```
寻找最小的数
第一轮[2, 24, 65, 12, 30, 63, 44, 22]
第二轮[2, 12, 65, 24, 30, 63, 44, 22]
第三轮[2, 12, 22, 24, 30, 63, 44, 65]
第四轮[2, 12, 22, 24, 30, 63, 44, 65]
第五轮[2, 12, 22, 24, 30, 63, 44, 65]
第六轮[2, 12, 22, 24, 30, 44, 63, 65]
第七轮[2, 12, 22, 24, 30, 44, 63, 65]
```

##  3、插入排序

**插入排序** 的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。

### 1. 算法步骤

1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。
2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）

![插入排序](http://ddrv.cn/docs/SortingAlgorithm/res/insertionSort.gif)

#### JavaScript 代码实现

```js
function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i < len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while(preIndex >= 0 && arr[preIndex] > current) {
            arr[preIndex+1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex+1] = current;
    }
    return arr;
}
insertionSort([23,44,1,3,32,12,5])//[1, 3, 5, 12, 23, 32, 44]
```
```
1.[23, 44, 1, 3, 32, 12, 5]
2.[1, 23, 44, 3, 32, 12, 5]
3.[1, 3, 23, 44, 32, 12, 5]
4.[1, 3, 23, 32, 44, 12, 5]
5.[1, 3, 12, 23, 32, 44, 5]
6.[1, 3, 5, 12, 23, 32, 44]
```




